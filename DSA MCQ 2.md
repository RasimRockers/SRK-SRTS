### âœ… Q1: Which of the following algorithms is the most efficient to **find all prime numbers up to a given number N**?

**A.** Trial division for each number

**B.** Sieve of Eratosthenes âœ…

**C.** Euclidean algorithm

**D.** Binary Search

---

### ğŸ…°ï¸ Answer: **B. Sieve of Eratosthenes**

---

### âœ… Q2. What algorithm is most suitable for scheduling CPU jobs with maximum profit and deadline?

**A.** Dijkstraâ€™s

**B.** Job Sequencing with Deadlines âœ…

**C.** Topological Sort

**D.** DFS

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: This greedy approach ensures maximum profit with deadline constraints.

---

### âœ… Q3. Which algorithm is best for **cycle detection** in a **directed graph**?

**A.** Primâ€™s

**B.** BFS

**C.** Topological Sort (DFS-based) âœ…

**D.** Dijkstraâ€™s

ğŸ…°ï¸: **C**
ğŸ’¬ **E**: DFS with recursion stack or Kahn's algorithm helps detect cycles in directed graphs.

---

### âœ… Q4. Which algorithm is most efficient to **sort a large dataset** in-memory?

**A.** Bubble Sort

**B.** Insertion Sort

**C.** Merge Sort âœ…

**D.** Linear Sort


ğŸ…°ï¸: **C**
ğŸ’¬ **E**: Merge Sort is a stable, divide-and-conquer algorithm with O(n log n) complexity.

---

### âœ… Q5. Which algorithm is best for finding the **Minimum Spanning Tree (MST)**?

**A.** Floyd-Warshall

**B.** Primâ€™s or Kruskalâ€™s âœ…

**C.** Bellman-Ford

**D.** DFS

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: Both Prim's and Kruskal's algorithms efficiently build an MST.

---

### âœ… Q6. Which is best for **finding shortest paths between all pairs** in a graph?

**A.** Dijkstra's

**B.** Bellman-Ford

**C.** DFS

**D.** Floyd-Warshall âœ…

ğŸ…°ï¸: **D**
ğŸ’¬ **E**: Floyd-Warshall uses dynamic programming to find all-pairs shortest paths.

---

### âœ… Q7. Which algorithm is used for **pattern matching in strings**?

**A.** Rabin-Karp âœ…

**B.** Dijkstraâ€™s

**C.** Kruskalâ€™s

**D.** DFS

ğŸ…°ï¸: **A**
ğŸ’¬ **E**: Rabin-Karp uses hashing to efficiently search patterns in text.

---

### âœ… Q8. Whatâ€™s the best algorithm to **balance a binary search tree**?

**A.** DFS

**B.** AVL Tree Rotations âœ…

**C.** BFS

**D.** Bubble Sort

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: AVL trees maintain balance using rotations.

---

### âœ… Q9. For **topological sorting** of a DAG, use:

**A.** BFS

**B.** Dijkstra

**C.** DFS âœ…

**D.** Prim


ğŸ…°ï¸: **C**
ğŸ’¬ **E**: DFS-based topological sort is ideal for DAGs.

---

### âœ… Q10. Best algorithm to find **connected components** in an undirected graph?

**A.** DFS or BFS âœ…

**B.** Prim's

**C.** Kruskal's

**D.** Floyd-Warshall

ğŸ…°ï¸: **A**
ğŸ’¬ **E**: DFS/BFS traverse components separately, perfect for finding all connected parts.

---

### âœ… Q11. Which is used for **maximum flow problems**?

**A.** Ford-Fulkerson âœ…

**B.** Kruskal

**C.** Bellman-Ford

**D.** Dijkstra

ğŸ…°ï¸: **A**
ğŸ’¬ **E**: Ford-Fulkerson computes the maximum flow in a flow network.

---

### âœ… Q12. Which algorithm solves the **0/1 Knapsack Problem** optimally?

**A.** Greedy

**B.** BFS

**C.** Dynamic Programming âœ…

**D.** DFS

ğŸ…°ï¸: **C**
ğŸ’¬ **E**: Dynamic Programming stores subproblem results for optimal 0/1 Knapsack solution.

---

### âœ… Q13. Which is ideal for **finding strongly connected components** in a graph?

**A.** DFS

**B.** Tarjanâ€™s or Kosarajuâ€™s Algorithm âœ…

**C.** BFS

**D.** Dijkstraâ€™s

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: These algorithms efficiently compute strongly connected components.

---

### âœ… Q14. Best suited algorithm to **search an element in a rotated sorted array**?

**A.** Linear Search

**B.** Binary Search with conditions âœ…

**C.** Merge Sort

**D.** DFS

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: A modified binary search handles the rotation condition.

---

### âœ… Q15. What is used for **maze solving or shortest path in unweighted grid**?

**A.** DFS

**B.** BFS âœ…

**C.** Dijkstraâ€™s

**D.** Greedy

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: BFS ensures the shortest path in unweighted graphs/grids.

---

### âœ… Q16. Which is used to detect **negative weight cycles**?

**A.** DFS

**B.** Dijkstra

**C.** Bellman-Ford âœ…

**D.** Floyd-Warshall

ğŸ…°ï¸: **C**
ğŸ’¬ **E**: Bellman-Ford can detect negative weight cycles by checking for further relaxation.

---

### âœ… Q17. Algorithm to **convert infix to postfix**?

**A.** BFS

**B.** Shunting Yard Algorithm âœ…

**C.** Dijkstra

**D.** KMP

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: Shunting Yard uses a stack-based approach to convert infix to postfix.

---

### âœ… Q18. For solving **subset sum problem**, the best algorithm is:

**A.** Greedy

**B.** Dynamic Programming âœ…

**C.** BFS

**D.** Kruskal

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: DP checks possible sums by building up subsets.

---

### âœ… Q19. Which algorithm is used to solve the **Travelling Salesman Problem (TSP)**?

**A.** DFS

**B.** Bellman-Ford

**C.** Dynamic Programming or Backtracking âœ…

**D.** Greedy

ğŸ…°ï¸: **C**
ğŸ’¬ **E**: TSP is NP-Hard; DP with memoization or backtracking gives exact solutions.

---

### âœ… Q20. Best algorithm for **finding articulation points** in a graph?

**A.** Kruskal

**B.** DFS (Tarjanâ€™s Algorithm) âœ…

**C.** BFS

**D.** Dijkstra

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: Tarjan's DFS-based algorithm detects cut vertices in O(V + E) time.

---

### âœ… Q21. Which algorithm is best for finding the shortest path in a weighted graph with non-negative weights?

**A.** DFS

**B.** BFS

**C.** Dijkstraâ€™s Algorithm âœ…

**D.** Kruskalâ€™s Algorithm

ğŸ…°ï¸: **C**
ğŸ’¬ **E**: Dijkstraâ€™s algorithm efficiently finds the shortest paths from a single source in graphs with non-negative weights.

---

### âœ… Q22. You want to detect if a **graph is bipartite**. What algorithm should you use?

**A.** DFS

**B.** BFS with coloring âœ…

**C.** Kruskalâ€™s

**D.** Dijkstra

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: BFS can be used to color nodes alternately to check bipartiteness.

---

### âœ… Q23. Which algorithm finds the **lowest common ancestor** in a BST?

**A.** DFS

**B.** Binary Search âœ…

**C.** BFS

**D.** Topological Sort

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: Use BST properties â€” left if smaller, right if greater, root is LCA.

---

### âœ… Q24. Which algorithm is optimal for finding **all permutations of a string**?

**A.** BFS

**B.** Backtracking âœ…

**C.** DP

**D.** Greedy

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: Backtracking explores all possible permutations using recursion.

---

### âœ… Q25. Which is best for **finding articulation points and bridges** in a graph?

**A.** Tarjanâ€™s Algorithm âœ…

**B.** Kruskalâ€™s

**C.** Dijkstra

**D.** Bellman-Ford

ğŸ…°ï¸: **A**
ğŸ’¬ **E**: Tarjanâ€™s DFS-based algorithm computes low and discovery time.

---

### âœ… Q26. What algorithm solves **maze with minimum turns**?

**A.** DFS

**B.** BFS with direction tracking âœ…

**C.** Floyd-Warshall

**D.** Bellman-Ford

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: You must track direction changes in BFS to count turns.

---

### âœ… Q27. What is used to **build a Huffman Encoding Tree**?

**A.** Stack

**B.** Max Heap

**C.** Min Heap âœ…

**D.** Binary Search Tree

ğŸ…°ï¸: **C**
ğŸ’¬ **E**: A min-heap helps pick two least frequent characters repeatedly.

---

### âœ… Q28. You need to detect **a cycle in an undirected graph**. Which is best?

**A.** DFS with visited and parent tracking âœ…

**B.** BFS with stack

**C.** Topological Sort

**D.** Floyd-Warshall

ğŸ…°ï¸: **A**
ğŸ’¬ **E**: DFS with parent information checks if visited neighbor â‰  parent.

---

### âœ… Q29. Algorithm for **maximum subarray sum** in O(n)?

**A.** Divide and Conquer

**B.** Kadaneâ€™s Algorithm âœ…

**C.** Greedy

**D.** Brute Force

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: Kadaneâ€™s dynamically tracks max sum subarray in linear time.

---

### âœ… Q30. Efficient algorithm for **matrix multiplication**?

**A.** Kruskalâ€™s

**B.** Strassenâ€™s Algorithm âœ…

**C.** Merge Sort

**D.** Floyd-Warshall

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: Strassenâ€™s reduces matrix multiplication complexity from O(nÂ³) to \~O(n^2.8).

---

### âœ… Q31. Algorithm to **generate power set of a set**?

**A.** Dynamic Programming

**B.** BFS

**C.** Bitmasking or Recursion âœ…

**D.** Binary Search

ğŸ…°ï¸: **C**
ğŸ’¬ **E**: Each subset can be represented using binary representation or recursive inclusion/exclusion.

---

### âœ… Q32. Which is best for checking if two strings are anagrams?

**A.** Bubble Sort

**B.** Sorting or Hash Table âœ…

**C.** DFS

**D.** Stack

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: Either count characters (hashing) or sort both strings.

---

### âœ… Q33. What algorithm is ideal to **simulate LRU cache**?

**A.** Array

**B.** HashMap + Doubly Linked List âœ…

**C.** Stack

**D.** Trie

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: HashMap provides O(1) lookup; doubly linked list maintains access order.

---

### âœ… Q34. Which algorithm is good for **job scheduling with minimum waiting time**?

**A.** Shortest Job First (SJF) âœ…

**B.** Round Robin

**C.** First Come First Serve

**D.** FIFO

ğŸ…°ï¸: **A**
ğŸ’¬ **E**: SJF minimizes average waiting time in scheduling jobs.

---

### âœ… Q35. You want to **serialize and deserialize** a binary tree. Use:

**A.** Inorder traversal

**B.** BFS (Level-order traversal) âœ…

**C.** Stack

**D.** Heap

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: Level order preserves structure better for reconstruction.

---

### âœ… Q36. Best algorithm to **implement a priority queue**?

**A.** Queue

**B.** Stack

**C.** Heap âœ…

**D.** Tree

ğŸ…°ï¸: **C**
ğŸ’¬ **E**: Heaps allow efficient insertion and removal of max/min.

---

### âœ… Q37. To **merge two sorted arrays** efficiently:

**A.** Two-pointer approach âœ…

**B.** QuickSort

**C.** Bubble Sort

**D.** DFS

ğŸ…°ï¸: **A**
ğŸ’¬ **E**: Two pointers traverse both arrays in linear time.

---

### âœ… Q38. Best algorithm for **finding the diameter of a tree**?

**A.** Inorder traversal

**B.** Two-pass DFS or BFS âœ…

**C.** Preorder traversal

**D.** Kruskalâ€™s

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: First DFS finds the farthest node, second DFS from that node finds the diameter.

---

### âœ… Q39. You want to find **common elements in 3 sorted arrays**. Use:

**A.** Hashing

**B.** Three-pointer technique âœ…

**C.** Merge Sort

**D.** Stack

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: Similar to two-pointer, but extended to 3 arrays.

---

### âœ… Q40. To **check for palindrome using O(1) space**:

**A.** Stack

**B.** Two-pointer technique âœ…

**C.** Recursion

**D.** Hash table

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: Compare characters from both ends with two pointers.

---

### âœ… Q41. You want to find **majority element** (>n/2 times). Use:

**A.** HashMap

**B.** Sorting

**C.** Boyer-Moore Voting Algorithm âœ…

**D.** Binary Search

ğŸ…°ï¸: **C**
ğŸ’¬ **E**: Boyer-Moore efficiently finds majority in O(n) and O(1) space.

---

### âœ… Q42. To check if a **number is prime**, use:

**A.** Trial Division up to âˆšn âœ…

**B.** Sieve of Eratosthenes

**C.** Binary Search

**D.** Bit Manipulation

ğŸ…°ï¸: **A**
ğŸ’¬ **E**: Trial division checks divisibility up to square root of the number.

---

### âœ… Q43. Which algorithm efficiently **generates all valid parentheses**?

**A.** BFS

**B.** DFS with backtracking âœ…

**C.** Heap

**D.** Stack

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: DFS/backtracking ensures balance between open and close.

---

### âœ… Q44. You want to check if a **graph is a tree**:

**A.** Topological sort

**B.** DFS + check cycle + connected âœ…

**C.** BFS

**D.** Primâ€™s

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: A tree is connected and acyclic.

---

### âœ… Q45. Which is ideal for **interval scheduling**?

**A.** DFS

**B.** Greedy with earliest finish time âœ…

**C.** DP

**D.** BFS

ğŸ…°ï¸: **B**
ğŸ’¬ **E**: Greedy approach ensures maximum jobs fit by choosing earliest finishing.

---

### âœ… Q46. For **text autocomplete**, the best data structure is:

**A.** Hash Map

**B.** Stack

**C.** Trie âœ…

**D.** Queue

ğŸ…°ï¸: **C**
ğŸ’¬ **E**: Tries allow fast prefix lookups and suggestions.

---

### âœ… Q47. Best algorithm to detect **duplicate elements in O(n)** time:

**A.** Hashing âœ…

**B.** Sorting

**C.** DFS

**D.** Stack

ğŸ…°ï¸: **A**
ğŸ’¬ **E**: A hash set tracks previously seen elements efficiently.

---

### âœ… Q48. Algorithm used to **find SCCs in directed graphs**?

**A.** Bellman-Ford

**B.** Dijkstra

**C.** Kosaraju or Tarjan âœ…

**D.** Topological Sort

ğŸ…°ï¸: **C**
ğŸ’¬ **E**: These efficiently find strongly connected components.

---

### âœ… Q49. What algorithm can detect **deadlock in OS Resource Allocation Graph**?

**A.** DFS with cycle detection âœ…

**B.** BFS

**C.** Topological Sort

**D.** SJF

ğŸ…°ï¸: **A**
ğŸ’¬ **E**: Deadlock detection reduces to detecting cycles in RAG.

---

### âœ… Q50. Which algorithm is best to **count number of islands** in a grid?

**A.** BFS or DFS âœ…

**B.** Dijkstra

**C.** Bit Manipulation

**D.** Heap

ğŸ…°ï¸: **A**
ğŸ’¬ **E**: Use DFS/BFS to explore all cells of each unvisited island.

---


### âœ… Q51. Which algorithm efficiently finds the **kth smallest element** in an unsorted array?

**A.** Merge Sort

**B.** QuickSort

**C.** QuickSelect âœ…

**D.** Heap Sort

ğŸ…°ï¸: **C**
ğŸ’¬ **E**: QuickSelect is a modified QuickSort that partitions only relevant half â€” average O(n).

---
