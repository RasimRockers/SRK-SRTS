### ✅ Q1: Which of the following algorithms is the most efficient to **find all prime numbers up to a given number N**?

**A.** Trial division for each number

**B.** Sieve of Eratosthenes ✅

**C.** Euclidean algorithm

**D.** Binary Search

---

### 🅰️ Answer: **B. Sieve of Eratosthenes**

---

### ✅ Q2. What algorithm is most suitable for scheduling CPU jobs with maximum profit and deadline?

**A.** Dijkstra’s

**B.** Job Sequencing with Deadlines ✅

**C.** Topological Sort

**D.** DFS

🅰️: **B**
💬 **E**: This greedy approach ensures maximum profit with deadline constraints.

---

### ✅ Q3. Which algorithm is best for **cycle detection** in a **directed graph**?

**A.** Prim’s

**B.** BFS

**C.** Topological Sort (DFS-based) ✅

**D.** Dijkstra’s

🅰️: **C**
💬 **E**: DFS with recursion stack or Kahn's algorithm helps detect cycles in directed graphs.

---

### ✅ Q4. Which algorithm is most efficient to **sort a large dataset** in-memory?

**A.** Bubble Sort

**B.** Insertion Sort

**C.** Merge Sort ✅

**D.** Linear Sort


🅰️: **C**
💬 **E**: Merge Sort is a stable, divide-and-conquer algorithm with O(n log n) complexity.

---

### ✅ Q5. Which algorithm is best for finding the **Minimum Spanning Tree (MST)**?

**A.** Floyd-Warshall

**B.** Prim’s or Kruskal’s ✅

**C.** Bellman-Ford

**D.** DFS

🅰️: **B**
💬 **E**: Both Prim's and Kruskal's algorithms efficiently build an MST.

---

### ✅ Q6. Which is best for **finding shortest paths between all pairs** in a graph?

**A.** Dijkstra's

**B.** Bellman-Ford

**C.** DFS

**D.** Floyd-Warshall ✅

🅰️: **D**
💬 **E**: Floyd-Warshall uses dynamic programming to find all-pairs shortest paths.

---

### ✅ Q7. Which algorithm is used for **pattern matching in strings**?

**A.** Rabin-Karp ✅

**B.** Dijkstra’s

**C.** Kruskal’s

**D.** DFS

🅰️: **A**
💬 **E**: Rabin-Karp uses hashing to efficiently search patterns in text.

---

### ✅ Q8. What’s the best algorithm to **balance a binary search tree**?

**A.** DFS

**B.** AVL Tree Rotations ✅

**C.** BFS

**D.** Bubble Sort

🅰️: **B**
💬 **E**: AVL trees maintain balance using rotations.

---

### ✅ Q9. For **topological sorting** of a DAG, use:

**A.** BFS

**B.** Dijkstra

**C.** DFS ✅

**D.** Prim


🅰️: **C**
💬 **E**: DFS-based topological sort is ideal for DAGs.

---

### ✅ Q10. Best algorithm to find **connected components** in an undirected graph?

**A.** DFS or BFS ✅

**B.** Prim's

**C.** Kruskal's

**D.** Floyd-Warshall

🅰️: **A**
💬 **E**: DFS/BFS traverse components separately, perfect for finding all connected parts.

---

### ✅ Q11. Which is used for **maximum flow problems**?

**A.** Ford-Fulkerson ✅

**B.** Kruskal

**C.** Bellman-Ford

**D.** Dijkstra

🅰️: **A**
💬 **E**: Ford-Fulkerson computes the maximum flow in a flow network.

---

### ✅ Q12. Which algorithm solves the **0/1 Knapsack Problem** optimally?

**A.** Greedy

**B.** BFS

**C.** Dynamic Programming ✅

**D.** DFS

🅰️: **C**
💬 **E**: Dynamic Programming stores subproblem results for optimal 0/1 Knapsack solution.

---

### ✅ Q13. Which is ideal for **finding strongly connected components** in a graph?

**A.** DFS

**B.** Tarjan’s or Kosaraju’s Algorithm ✅

**C.** BFS

**D.** Dijkstra’s

🅰️: **B**
💬 **E**: These algorithms efficiently compute strongly connected components.

---

### ✅ Q14. Best suited algorithm to **search an element in a rotated sorted array**?

**A.** Linear Search

**B.** Binary Search with conditions ✅

**C.** Merge Sort

**D.** DFS

🅰️: **B**
💬 **E**: A modified binary search handles the rotation condition.

---

### ✅ Q15. What is used for **maze solving or shortest path in unweighted grid**?

**A.** DFS

**B.** BFS ✅

**C.** Dijkstra’s

**D.** Greedy

🅰️: **B**
💬 **E**: BFS ensures the shortest path in unweighted graphs/grids.

---

### ✅ Q16. Which is used to detect **negative weight cycles**?

**A.** DFS

**B.** Dijkstra

**C.** Bellman-Ford ✅

**D.** Floyd-Warshall

🅰️: **C**
💬 **E**: Bellman-Ford can detect negative weight cycles by checking for further relaxation.

---

### ✅ Q17. Algorithm to **convert infix to postfix**?

**A.** BFS

**B.** Shunting Yard Algorithm ✅

**C.** Dijkstra

**D.** KMP

🅰️: **B**
💬 **E**: Shunting Yard uses a stack-based approach to convert infix to postfix.

---

### ✅ Q18. For solving **subset sum problem**, the best algorithm is:

**A.** Greedy

**B.** Dynamic Programming ✅

**C.** BFS

**D.** Kruskal

🅰️: **B**
💬 **E**: DP checks possible sums by building up subsets.

---

### ✅ Q19. Which algorithm is used to solve the **Travelling Salesman Problem (TSP)**?

**A.** DFS

**B.** Bellman-Ford

**C.** Dynamic Programming or Backtracking ✅

**D.** Greedy

🅰️: **C**
💬 **E**: TSP is NP-Hard; DP with memoization or backtracking gives exact solutions.

---

### ✅ Q20. Best algorithm for **finding articulation points** in a graph?

**A.** Kruskal

**B.** DFS (Tarjan’s Algorithm) ✅

**C.** BFS

**D.** Dijkstra

🅰️: **B**
💬 **E**: Tarjan's DFS-based algorithm detects cut vertices in O(V + E) time.

---

### ✅ Q21. Which algorithm is best for finding the shortest path in a weighted graph with non-negative weights?

**A.** DFS

**B.** BFS

**C.** Dijkstra’s Algorithm ✅

**D.** Kruskal’s Algorithm

🅰️: **C**
💬 **E**: Dijkstra’s algorithm efficiently finds the shortest paths from a single source in graphs with non-negative weights.

---

### ✅ Q22. You want to detect if a **graph is bipartite**. What algorithm should you use?

**A.** DFS

**B.** BFS with coloring ✅

**C.** Kruskal’s

**D.** Dijkstra

🅰️: **B**
💬 **E**: BFS can be used to color nodes alternately to check bipartiteness.

---

### ✅ Q23. Which algorithm finds the **lowest common ancestor** in a BST?

**A.** DFS

**B.** Binary Search ✅

**C.** BFS

**D.** Topological Sort

🅰️: **B**
💬 **E**: Use BST properties — left if smaller, right if greater, root is LCA.

---

### ✅ Q24. Which algorithm is optimal for finding **all permutations of a string**?

**A.** BFS

**B.** Backtracking ✅

**C.** DP

**D.** Greedy

🅰️: **B**
💬 **E**: Backtracking explores all possible permutations using recursion.

---

### ✅ Q25. Which is best for **finding articulation points and bridges** in a graph?

**A.** Tarjan’s Algorithm ✅

**B.** Kruskal’s

**C.** Dijkstra

**D.** Bellman-Ford

🅰️: **A**
💬 **E**: Tarjan’s DFS-based algorithm computes low and discovery time.

---

### ✅ Q26. What algorithm solves **maze with minimum turns**?

**A.** DFS

**B.** BFS with direction tracking ✅

**C.** Floyd-Warshall

**D.** Bellman-Ford

🅰️: **B**
💬 **E**: You must track direction changes in BFS to count turns.

---

### ✅ Q27. What is used to **build a Huffman Encoding Tree**?

**A.** Stack

**B.** Max Heap

**C.** Min Heap ✅

**D.** Binary Search Tree

🅰️: **C**
💬 **E**: A min-heap helps pick two least frequent characters repeatedly.

---

### ✅ Q28. You need to detect **a cycle in an undirected graph**. Which is best?

**A.** DFS with visited and parent tracking ✅

**B.** BFS with stack

**C.** Topological Sort

**D.** Floyd-Warshall

🅰️: **A**
💬 **E**: DFS with parent information checks if visited neighbor ≠ parent.

---

### ✅ Q29. Algorithm for **maximum subarray sum** in O(n)?

**A.** Divide and Conquer

**B.** Kadane’s Algorithm ✅

**C.** Greedy

**D.** Brute Force

🅰️: **B**
💬 **E**: Kadane’s dynamically tracks max sum subarray in linear time.

---

### ✅ Q30. Efficient algorithm for **matrix multiplication**?

**A.** Kruskal’s

**B.** Strassen’s Algorithm ✅

**C.** Merge Sort

**D.** Floyd-Warshall

🅰️: **B**
💬 **E**: Strassen’s reduces matrix multiplication complexity from O(n³) to \~O(n^2.8).

---

### ✅ Q31. Algorithm to **generate power set of a set**?

**A.** Dynamic Programming

**B.** BFS

**C.** Bitmasking or Recursion ✅

**D.** Binary Search

🅰️: **C**
💬 **E**: Each subset can be represented using binary representation or recursive inclusion/exclusion.

---

### ✅ Q32. Which is best for checking if two strings are anagrams?

**A.** Bubble Sort

**B.** Sorting or Hash Table ✅

**C.** DFS

**D.** Stack

🅰️: **B**
💬 **E**: Either count characters (hashing) or sort both strings.

---

### ✅ Q33. What algorithm is ideal to **simulate LRU cache**?

**A.** Array

**B.** HashMap + Doubly Linked List ✅

**C.** Stack

**D.** Trie

🅰️: **B**
💬 **E**: HashMap provides O(1) lookup; doubly linked list maintains access order.

---

### ✅ Q34. Which algorithm is good for **job scheduling with minimum waiting time**?

**A.** Shortest Job First (SJF) ✅

**B.** Round Robin

**C.** First Come First Serve

**D.** FIFO

🅰️: **A**
💬 **E**: SJF minimizes average waiting time in scheduling jobs.

---

### ✅ Q35. You want to **serialize and deserialize** a binary tree. Use:

**A.** Inorder traversal

**B.** BFS (Level-order traversal) ✅

**C.** Stack

**D.** Heap

🅰️: **B**
💬 **E**: Level order preserves structure better for reconstruction.

---

### ✅ Q36. Best algorithm to **implement a priority queue**?

**A.** Queue

**B.** Stack

**C.** Heap ✅

**D.** Tree

🅰️: **C**
💬 **E**: Heaps allow efficient insertion and removal of max/min.

---

### ✅ Q37. To **merge two sorted arrays** efficiently:

**A.** Two-pointer approach ✅

**B.** QuickSort

**C.** Bubble Sort

**D.** DFS

🅰️: **A**
💬 **E**: Two pointers traverse both arrays in linear time.

---

### ✅ Q38. Best algorithm for **finding the diameter of a tree**?

**A.** Inorder traversal

**B.** Two-pass DFS or BFS ✅

**C.** Preorder traversal

**D.** Kruskal’s

🅰️: **B**
💬 **E**: First DFS finds the farthest node, second DFS from that node finds the diameter.

---

### ✅ Q39. You want to find **common elements in 3 sorted arrays**. Use:

**A.** Hashing

**B.** Three-pointer technique ✅

**C.** Merge Sort

**D.** Stack

🅰️: **B**
💬 **E**: Similar to two-pointer, but extended to 3 arrays.

---

### ✅ Q40. To **check for palindrome using O(1) space**:

**A.** Stack

**B.** Two-pointer technique ✅

**C.** Recursion

**D.** Hash table

🅰️: **B**
💬 **E**: Compare characters from both ends with two pointers.

---

### ✅ Q41. You want to find **majority element** (>n/2 times). Use:

**A.** HashMap

**B.** Sorting

**C.** Boyer-Moore Voting Algorithm ✅

**D.** Binary Search

🅰️: **C**
💬 **E**: Boyer-Moore efficiently finds majority in O(n) and O(1) space.

---

### ✅ Q42. To check if a **number is prime**, use:

**A.** Trial Division up to √n ✅

**B.** Sieve of Eratosthenes

**C.** Binary Search

**D.** Bit Manipulation

🅰️: **A**
💬 **E**: Trial division checks divisibility up to square root of the number.

---

### ✅ Q43. Which algorithm efficiently **generates all valid parentheses**?

**A.** BFS

**B.** DFS with backtracking ✅

**C.** Heap

**D.** Stack

🅰️: **B**
💬 **E**: DFS/backtracking ensures balance between open and close.

---

### ✅ Q44. You want to check if a **graph is a tree**:

**A.** Topological sort

**B.** DFS + check cycle + connected ✅

**C.** BFS

**D.** Prim’s

🅰️: **B**
💬 **E**: A tree is connected and acyclic.

---

### ✅ Q45. Which is ideal for **interval scheduling**?

**A.** DFS

**B.** Greedy with earliest finish time ✅

**C.** DP

**D.** BFS

🅰️: **B**
💬 **E**: Greedy approach ensures maximum jobs fit by choosing earliest finishing.

---

### ✅ Q46. For **text autocomplete**, the best data structure is:

**A.** Hash Map

**B.** Stack

**C.** Trie ✅

**D.** Queue

🅰️: **C**
💬 **E**: Tries allow fast prefix lookups and suggestions.

---

### ✅ Q47. Best algorithm to detect **duplicate elements in O(n)** time:

**A.** Hashing ✅

**B.** Sorting

**C.** DFS

**D.** Stack

🅰️: **A**
💬 **E**: A hash set tracks previously seen elements efficiently.

---

### ✅ Q48. Algorithm used to **find SCCs in directed graphs**?

**A.** Bellman-Ford

**B.** Dijkstra

**C.** Kosaraju or Tarjan ✅

**D.** Topological Sort

🅰️: **C**
💬 **E**: These efficiently find strongly connected components.

---

### ✅ Q49. What algorithm can detect **deadlock in OS Resource Allocation Graph**?

**A.** DFS with cycle detection ✅

**B.** BFS

**C.** Topological Sort

**D.** SJF

🅰️: **A**
💬 **E**: Deadlock detection reduces to detecting cycles in RAG.

---

### ✅ Q50. Which algorithm is best to **count number of islands** in a grid?

**A.** BFS or DFS ✅

**B.** Dijkstra

**C.** Bit Manipulation

**D.** Heap

🅰️: **A**
💬 **E**: Use DFS/BFS to explore all cells of each unvisited island.

---


### ✅ Q51. Which algorithm efficiently finds the **kth smallest element** in an unsorted array?

**A.** Merge Sort

**B.** QuickSort

**C.** QuickSelect ✅

**D.** Heap Sort

🅰️: **C**
💬 **E**: QuickSelect is a modified QuickSort that partitions only relevant half — average O(n).

---
